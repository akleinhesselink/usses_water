---
layout: 11pt
header-includes:
  - \usepackage{lineno}
  - \linenumbers
  - \usepackage{setspace}
  - \usepackage{todonotes}
  - \onehalfspacing
  - \usepackage{rotating}
  - \usepackage{color, soul}
  - \usepackage[font={small},labelfont={bf},labelsep=quad]{caption}
  - \usepackage{tikz}
  - \usepackage{bm,mathrsfs}
  - \usepackage[sc]{mathpazo}
bibliography: ~/Dropbox/Bibliography/usses_water.bib
csl: components/ecology.csl

## rmarkdown render options
output:
  pdf_document:
    fig_caption: true
    keep_tex: false
    number_sections: true
fontsize: 11pt
geometry: margin=1in
linkcolor: black
urlcolor: black
---

\newcommand{\tikzcircle}[2][red,fill=red]{\tikz[baseline=-0.5ex]\draw[#1,radius=#2] (0,0) circle ;}
\renewcommand\linenumberfont{\normalfont\tiny\sffamily\color{gray}}
\renewcommand\thefigure{A2-\arabic{figure}}
\renewcommand\theequation{A2.\arabic{equation}}
\renewcommand\thetable{A2-\arabic{table}}  
\renewcommand\thesection{Section A2.\arabic{section}}

\begin{center}
\textbf{\Large{Appendix 2}} \\
A.T. Tredennick, A.R. Kleinhesselink, \& P.B. Adler \\
``Ecosystem and community resistance...'' \\
\emph{PeerJ}
\end{center}

\section{Random Slopes, Random Intercepts Model}
\subsection{Model Description}
Our hierarchical Bayesian model with random intercepts and random slopes allowed us to test for differences among treatments in the relationship between ANPP and growing season precipitation, and allowed us to account for the non-independence of observations through time within a plot.
The random effects structure mirrors the nested structure of the data: plot-level parameters are nested within treatment-level parameters, which are nested within overall parameters.
In what follows, $\textbf{X}$ is the design matrix including a column of 1s for intercepts and a column of precipitation values for each observation, $\textbf{y}$ is a row vector of log(ANPP) values for each observation, *i* references observations, *j* references plots, and *k* references treatment.
The notation *i(j(k))* reads as 'observation *i* associated with plot *j* associated with treatment *k*'.
Recall we have three treatments: drought (~50\% decrease in precipitation), control (ambient precipitation), and irrigation (~50\% increase in precipitation).

We assume the observations are conditionally Gaussian,

\vspace{-2em}

\begin{align}
y_{i(j(k))} \sim \text{Normal}\left(\mu_{i(j(k))}, \sigma^2_k \right),
\end{align}

\noindent{}where $\mu_{i(j(k))}$ is the determinstic expectation from the regression model,

\vspace{-2em}

\begin{align}
\mu_{i(j(k))} = \textbf{x}_i'\boldsymbol{\beta_{j(k)}}.
\end{align}

Regression parameters (the intercept and slope in the parameter vector $\boldsymbol{\beta}$) were modeled hierarchically,

\vspace{-2em}

\begin{align}
\boldsymbol{\beta}_{j(k)} &\sim \text{MVN} \left( \boldsymbol{\beta}_k, \boldsymbol{\Sigma}(k) \right), \\
\boldsymbol{\beta}_{k} &\sim \text{MVN} \left( \boldsymbol{\beta}, \boldsymbol{\Sigma}  \right), \\
\boldsymbol{\beta} &\sim \text{Normal} \left( 0, 1 \right),
\end{align}

\noindent{} where $\boldsymbol{\beta}_{j(k)}$ is the vector of regression coefficients (intercept and slope) for plot *j* associated with treatment *k*, $\boldsymbol{\beta}_{k}$ is the vector of coefficients for each treatment, and $\boldsymbol{\beta}$ is the vector of overall coefficients.
The plot- and treatment-level coefficients are drawn from multivariate normal distributions with covariance matrix $\boldsymbol{\Sigma}$.
For the plot-level coefficients, each treatment has its own variance-covariance matrix (i.e., $\boldsymbol{\Sigma}(k)$).
The overall coefficients are drawn from a normal prior with mean 0 and standard deviation 1.

We fit the model using MCMC as implemented in the software Stan [@stan2016].
Our Stan code is below.
All code necessary to reproduce our results is in the supplementary code set (Appendix 3).

\subsection{Stan Code}
```{r stan1, echo=T, eval=F}
data {
  int<lower=0> Npreds;        # number of covariates, including intercept
  int<lower=0> Nplots;        # number of plots
  int<lower=0> Ntreats;       # number of treatments
  int<lower=0> Nobs;          # number of observations
  int<lower=0> Nppts;         # Number of precip levels to predict
  vector[Nobs] y;             # vector of observations
  row_vector[Npreds] x[Nobs]; # design matrix
  matrix[Nppts,Npreds] newx;  # design matrix for predictions 
  matrix[Npreds,Npreds] R;	  # priors for covariance matrix
  int plot_id[Nobs];          # vector of plot ids
  int treat_id[Nobs];         # vector of treatment ids
}

parameters {
  vector[Npreds] beta_plot[Nplots]; # a unique vector matrix for each plot
  vector[Npreds] beta_treat[Ntreats]; # a unique vector matrix for each treatment
	vector[Npreds] beta_mu; # overall coefficients
	cov_matrix[Npreds] Sigma; # covariance matrix for treatment-level coefficients
	cov_matrix[Npreds] Sigma_plot[Ntreats]; # unique covariance matrix for plot-level coefs by treatment
	vector<lower=0>[Ntreats] sd_y; # treatment-level observation std. dev.
}

transformed parameters {
  vector[Nobs] yhat; # vector of expected values (predictions)
  for (i in 1:Nobs)
    # regression model for expected values (one for each plot-year)
    yhat[i] = x[i]*beta_plot[plot_id[i]]; 
}

model {
  ####  PRIORS
  for(i in 1:Nplots)
    # plot-level coefficients vary normally around treatment coefs
		beta_plot[i] ~ multi_normal(beta_treat[treat_id[i]], Sigma_plot[treat_id[i]]);
	
	for(i in 1:Ntreats){
	  # treatment-level coefficients vary normally around overall coefficients
	  beta_treat[i] ~ multi_normal(beta_mu, Sigma); 
	  
	  # priors on covariance of effects at plot-level
	  Sigma_plot[i] ~ inv_wishart(Npreds+1, R);
	}
	
	beta_mu ~ normal(0,1); # priors on overall effects
	Sigma ~ inv_wishart(Npreds+1, R); # priors on covariance of effects at treatment-level
	sd_y ~ weibull(2,1); # priors on observation std. dev. for each treatment

	####  LIKELIHOOD
	for(i in 1:Nobs)
	  # observations vary normally around expected values
	  y[i] ~ normal(yhat[i], sd_y[treat_id[i]]);
}

generated quantities {
  vector[Nppts] ypreds[Ntreats];
  vector[Nppts] ydiff_control_drought;
  vector[Nppts] ydiff_control_irrigate;
  vector[2] inter_diffs;
  for(i in 1:Ntreats)
    ypreds[i] = newx*beta_treat[i]; # mean predictions for each treatment
  
  # difference between mean predictions
  ydiff_control_drought = ypreds[1] - ypreds[2]; 
  ydiff_control_irrigate = ypreds[1] - ypreds[3];
  
  # difference between control and treatment in avg ppt year
  inter_diffs[1] = beta_treat[1][1] - beta_treat[2][1]; # control - drought
  inter_diffs[2] = beta_treat[1][1] - beta_treat[3][1]; # control - irrigation
}

```


# References
